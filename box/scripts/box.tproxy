#!/system/bin/sh

# 设置环境变量
export PATH="/data/adb/magisk:/data/adb/ksu/bin:/data/adb/ap/bin:$PATH:/data/data/com.termux/files/usr/bin"

# 常量定义
readonly SCRIPTS="$(realpath "$0")"
readonly SCRIPTS_DIR="$(dirname "$SCRIPTS")"
readonly CONFIG_FILE="${SCRIPTS_DIR}/box.config"
readonly MARK_ID="16777216/16777216"
readonly TABLE_ID="2025"
# core 流量标记
# 在 core uid match return 失败时考虑使用
# 具体配置格式请查阅 core 文档并了解本机透明代理
readonly ROUTING_MARK="233"
readonly IPTABLES_TIMEOUT="100"

# 日志
log() {
  local level="$1"
  local message="$2"
  local timestamp="$(date +"%Y-%m-%d %H:%M:%S")"
  local color_code="\033[0m"

  case $level in
    Debug) color_code="\033[0;36m" ;;
    Info) color_code="\033[1;32m" ;;
    Warn) color_code="\033[1;33m" ;;
    Error) color_code="\033[1;31m" ;;
  esac

  [ -t 1 ] \
    && echo -e "${color_code}${timestamp} [${level}]: ${message}\033[0m" \
    || echo "${timestamp} [${level}]: ${message}"
}

# 检查依赖
check_dependencies() {
  local missing=()
  local required_commands=(busybox ip iptables)

  for cmd in "${required_commands[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if [ ${#missing[@]} -gt 0 ]; then
    log Error "Missing required commands: ${missing[*]}"
    log Info "Check PATH: $PATH"
    exit 1
  fi

  # 验证 busybox 必要小工具
  # local required_applets=(awk cut grep pidof stat)
  # for applet in "${required_applets[@]}"; do
  #  if ! busybox --list | grep -q "^${applet}\$"; then
  #    log Error "busybox missing applet: $applet"
  #    exit 1
  #  fi
  # done
}

# 检查内核特性
check_kernel_feature() {
  local feature="$1"
  local config_name="CONFIG_${feature}"

  if [ -f /proc/config.gz ]; then
    zcat /proc/config.gz | grep -qE "^${config_name}=[ym]$"
  else
    # 备用方法：检查模块是否加载（仅检测模块，内置功能需其他方法比如检查 dmesg）
    # lsmod | grep -q "$feature" || return 1
    return 1
  fi
}

# 加载配置文件
load_config() {
  [ -f "${CONFIG_FILE}" ] || {
    log Error "Config file ${CONFIG_FILE} not found"
    exit 1
  }
  source "${CONFIG_FILE}" || {
    log Error "Failed to load config file"
    exit 1
  }
}

# 检查必需参数
validate_vars() {
  local required_vars=("$@")
  for var in "${required_vars[@]}"; do
    [ -z "${!var}" ] && {
      log Error "Missing required var: $var"
      return 1
    }
  done

  return 0
}

# 用户与组解析
validate_user_group() {
  IFS=':' read -r box_user box_group <<<"${box_user_group}"
  [ -z "${box_user}" ] || [ -z "{$box_group}" ] && {
    log Error "Invalid box_user_group format"
    box_user="root"
    box_group="net_admin"
    log Info "Falling back to default box_user_group: ${box_user}:${box_group}"
  }
}

# 包名查找 UID
find_packages_uid() {
  uid_list=()
  for user_package in "${user_packages_list[@]}"; do
    local user="$(echo "${user_package}" | cut -d: -f1)"
    local package="$(echo "${user_package}" | cut -d: -f2)"
    local uid="$(awk -v pkg="${package}" '$1 == pkg {print $2}' /data/system/packages.list)"
    [ -n "$uid" ] && uid_list+=($((user * 100000 + uid)))
  done
}

# 探测 core 运行用户与组
probe_core_user_group() {
  # 尝试通过 pidof 获取进程 ID
  if bin_pid=$(pidof "${bin_name}" 2>/dev/null); then
    log Debug "Found ${bin_name} PID via pidof: ${bin_pid}"
  else
    # pidof 失败时，尝试从 pid_file 中读取 PID
    if [ -f "${pid_file}" ]; then
      bin_pid="$(cat "${pid_file}" 2>/dev/null)"
      if [ -n "${bin_pid}" ] && [ "${bin_pid}" -eq "${bin_pid}" ] 2>/dev/null; then
        log Debug "Found ${bin_name} PID via pid_file: ${bin_pid}"
      else
        log Warn "Invalid PID in ${pid_file}: ${bin_pid}"
        bin_pid=""
      fi
    else
      log Warn "pid_file not found: ${pid_file}"
      bin_pid=""
    fi
  fi

  # 如果成功获取 PID，尝试读取用户和组
  if [ -n "${bin_pid}" ]; then
    if [ -d "/proc/${bin_pid}" ]; then
      box_user="$(stat -c %U "/proc/${bin_pid}" 2>/dev/null)"
      box_group="$(stat -c %G "/proc/${bin_pid}" 2>/dev/null)"
      if [ -n "${box_user}" ] && [ -n "${box_group}" ]; then
        log Info "Detected ${bin_name} running as ${box_user}:${box_group}"
        return 0
      else
        log Warn "Failed to get user/group for PID ${bin_pid}"
      fi
    else
      log Warn "Process directory not found: /proc/${bin_pid}"
    fi
  fi

  return 1
}

# 增删 TPROXY 策略路由
ad_ip_rules() {
  ${ip_cmd} rule "$1" fwmark ${MARK_ID} table ${TABLE_ID} pref ${TABLE_ID}
  ${ip_cmd} route "$2" local default dev lo table ${TABLE_ID}
}

# 添加 iptables 规则
add_ipt_rule() {
  local action="$1"
  local table="$2"
  local chain="$3"
  local rule="$4"
  # local ipt_cmd="$5"

  # if [ "$ipt_cmd" = "v6" ]; then
  #   ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
  # else
  #   ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
  # fi

  if [ "$action" = "N" ] || [ -z "$rule" ]; then
    if ! ${ipt_cmd} -t "${table}" -L "${chain}" >/dev/null 2>&1; then
      ${ipt_cmd} -t "${table}" -N "${chain}" || {
        log Error "Failed to create chain: ${ipt_cmd} -t ${table} -N ${chain}"
        return 1
      }
      log Debug "Created chain: ${ipt_cmd} -t ${table} -N ${chain}"
      return 0
    else
      log Debug "Rule exists: ${ipt_cmd} -t ${table} -N ${chain}"
      return 2
    fi
  fi

  if ! ${ipt_cmd} -t "${table}" -C "${chain}" "${rule}" >/dev/null 2>&1; then
    ${ipt_cmd} -t "${table}" -"${action}" "${chain}" "${rule}" || {
      log Error "Failed to add rule: ${ipt_cmd} -t ${table} -${action} ${chain} ${rule}"
      return 1
    }
    log Debug "Added rule: ${ipt_cmd} -t ${table} -${action} ${chain} ${rule}"
    return 0
  else
    log Debug "Rule exists: ${ipt_cmd} -t ${table} -${action} ${chain} ${rule}"
    return 2
  fi
}

# 启动 REDIRECT 模式
start_redirect() {
  add_ipt_rule N nat BOX_EXTERNAL
  add_ipt_rule N nat BOX_LOCAL

  # handle_core_return_rules nat BOX_EXTERNAL
  handle_core_return_rules nat BOX_LOCAL

  handle_ignore_out_rules nat

  handle_dns_rules redirect

  handle_intranet_rules nat BOX_EXTERNAL
  handle_intranet_rules nat BOX_LOCAL

  handle_proxy_mode nat

  handle_ap_rules nat "${redir_port}"

  add_ipt_rule I nat PREROUTING "-j BOX_EXTERNAL"
  add_ipt_rule I nat OUTPUT "-j BOX_LOCAL"
}

# 启动 TPROXY 模式
start_tproxy() {
  ad_ip_rules add add

  add_ipt_rule A mangle BOX_EXTERNAL
  add_ipt_rule N mangle BOX_LOCAL

  # handle_core_return_rules mangle BOX_EXTERNAL
  handle_core_return_rules mangle BOX_LOCAL

  handle_ignore_out_rules mangle

  handle_dns_rules tproxy

  handle_intranet_rules mangle BOX_EXTERNAL
  handle_intranet_rules mangle BOX_LOCAL

  handle_proxy_mode mangle

  handle_ap_rules mangle "${tproxy_port}"

  add_ipt_rule I mangle PREROUTING "-j BOX_EXTERNAL"
  add_ipt_rule I mangle OUTPUT "-j BOX_LOCAL"

  handle_divert_rules
}

# 清理 REDIRECT 模式
stop_redirect() {
  log Info "Cleaning REDIRECT rules"

  ${ipt_cmd} -t nat -D PREROUTING -j BOX_EXTERNAL
  ${ipt_cmd} -t nat -D OUTPUT -j BOX_LOCAL

  ${ipt_cmd} -t nat -F BOX_EXTERNAL
  ${ipt_cmd} -t nat -X BOX_EXTERNAL
  ${ipt_cmd} -t nat -F BOX_LOCAL
  ${ipt_cmd} -t nat -X BOX_LOCAL
  iptables -t nat -F LOCAL_IP_V4
  iptables -t nat -X LOCAL_IP_V4
  ip6tables -t nat -F LOCAL_IP_V6
  ip6tables -t nat -X LOCAL_IP_V6

  fix_fakeip_icmp disable
  reject_local_traffic disable "${redir_port}"
}

# 清理 TPROXY 模式
stop_tproxy() {
  log Info "Cleaning TPROXY rules"

  ad_ip_rules del flush

  ${ipt_cmd} -t mangle -D PREROUTING -j BOX_EXTERNAL

  ${ipt_cmd} -t mangle -D PREROUTING -p tcp -m socket -j DIVERT

  ${ipt_cmd} -t mangle -D OUTPUT -j BOX_LOCAL

  ${ipt_cmd} -t mangle -F BOX_EXTERNAL
  ${ipt_cmd} -t mangle -X BOX_EXTERNAL

  ${ipt_cmd} -t mangle -F BOX_LOCAL
  ${ipt_cmd} -t mangle -X BOX_LOCAL

  iptables -t mangle -F LOCAL_IP_V4
  iptables -t mangle -X LOCAL_IP_V4
  ip6tables -t mangle -F LOCAL_IP_V6
  ip6tables -t mangle -X LOCAL_IP_V6

  ${ipt_cmd} -t mangle -F DIVERT
  ${ipt_cmd} -t mangle -X DIVERT

  fix_fakeip_icmp disable
  reject_local_traffic disable "${tproxy_port}"
}

stop_dns_redirect() {
  ${ipt_cmd} -t nat -D PREROUTING -j DNS_EXTERNAL
  ${ipt_cmd} -t nat -D OUTPUT -j DNS_LOCAL

  ${ipt_cmd} -t nat -F DNS_EXTERNAL
  ${ipt_cmd} -t nat -X DNS_EXTERNAL

  ${ipt_cmd} -t nat -F DNS_LOCAL
  ${ipt_cmd} -t nat -X DNS_LOCAL
}

# 处理内网路由规则
handle_intranet_rules() {
  local table="$1"
  local chain="$2"

  case "$ipt_cmd" in
    iptables*)
      local subnets=("${intranet[@]}")
      local local_subnets=("${intranet_subnets[@]}")
      local local_chain="LOCAL_IP_V4"
      ;;
    ip6tables*)
      local subnets=("${intranet6[@]}")
      local local_subnets=("${intranet6_subnets[@]}")
      local local_chain="LOCAL_IP_V6"
      ;;
  esac

  if check_kernel_feature "NETFILTER_XT_MATCH_ADDRTYPE"; then
    add_ipt_rule A "$table" "$chain" "-m addrtype --dst-type LOCAL -j RETURN"
  fi

  for subnet in "${subnets[@]}"; do
    add_ipt_rule A "$table" "$chain" "-d ${subnet} -j RETURN"
  done

  add_ipt_rule N "$table" "$local_chain"

  for local_ip in "${local_subnets[@]}"; do
    add_ipt_rule A "$table" "${local_chain}" "-d ${local_ip} -j ACCEPT"
  done

  add_ipt_rule A "$table" "$chain" "-j ${local_chain}"
}

# 处理代理接口规则
# Allow ap interface
# Notice: Old android device may only have one wlan interface
# Some new android device have multiple wlan interface like wlan0(for internet), wlan1(for AP)
handle_ap_rules() {
  local table="$1"
  local port="$2"
  local ipt_rule
  local proto_list

  case "$table" in
    nat)
      ipt_rule="-j REDIRECT --to-ports ${port}"
      proto_list=("tcp")
      ;;
    mangle)
      ipt_rule="-j TPROXY --on-port ${port} --tproxy-mark ${MARK_ID}"
      proto_list=("tcp" "udp")
      ;;
  esac

  ap_list+=("lo")

  for ap in "${ap_list[@]}"; do
    for proto in "${proto_list[@]}"; do
      add_ipt_rule A "$table" BOX_EXTERNAL "-p $proto -i $ap $ipt_rule" "$3"
    done
  done
  log Info "Interfaces configured for transparent proxy: ${ap_list[*]}"
}

# 处理 core 自身流量绕过规则
handle_core_return_rules() {
  local table="$1"
  local chain="$2"

  if check_kernel_feature "NETFILTER_XT_MATCH_OWNER"; then
    add_ipt_rule A "$table" "$chain" "-m owner --uid-owner ${box_user} --gid-owner ${box_group} -j RETURN"
  elif check_kernel_feature "NETFILTER_XT_MATCH_MARK"; then
    log Warn "owner match not supported, falling back to mark match"
    add_ipt_rule A "$table" "$chain" "-m mark --mark ${ROUTING_MARK} -j RETURN"
  fi
}

# 处理忽略代理接口规则
handle_ignore_out_rules() {
  local table="$1"

  {
    for ignore in "${ignore_out_list[@]}"; do
      if $ignore != "lo"; then
        add_ipt_rule A "$table" BOX_LOCAL "-o ${ignore} -j RETURN"
      fi
    done
  } \
    && log Info "Interfaces ignored for transparent proxy: ${ignore_out_list[*]}"
}

# 处理代理模式规则
handle_proxy_mode() {
  local table="$1"

  if [ ${#uid_list[@]} -eq 0 ] && [ ${#gid_list[@]} -eq 0 ]; then
    handle_default_mode
    log Info "No UID or GID specified, defaulting to proxy all traffic"
    return 0
  fi

  if ! check_kernel_feature "NETFILTER_XT_MATCH_OWNER"; then
    log Error "owner match not supported, blacklist and whitelist cannot be used"
    return 1
  fi

  case "${proxy_mode}" in
    blacklist)
      handle_blacklist_mode "${table}"
      ;;
    whitelist)
      handle_whitelist_mode "${table}"
      ;;
    *)
      log Warn "Invalid proxy mode: ${proxy_mode}, defaulting to proxy all traffic"
      handle_default_mode "${table}"
      ;;
  esac
}

# 处理默认模式代理规则
handle_default_mode() {
  local table="$1"

  case "${table}" in
    nat)
      add_ipt_rule A nat BOX_LOCAL "-p tcp -j REDIRECT --to-ports ${redir_port}"
      ;;
    mangle)
      add_ipt_rule A mangle BOX_LOCAL "-p tcp -j MARK --set-xmark ${MARK_ID}"
      add_ipt_rule A mangle BOX_LOCAL "-p udp -j MARK --set-xmark ${MARK_ID}"
      ;;
  esac
}

# 处理黑名单模式规则
handle_blacklist_mode() {
  local table="$1"

  # Bypass uid
  handle_user_group_rules "$table" "blacklist" "uid"

  # Bypass gid
  handle_user_group_rules "$table" "blacklist" "gid"

  # Allow !uid/gid
  handle_default_mode "${table}"
}

# 处理白名单模式规则
handle_whitelist_mode() {
  local table="$1"

  # Allow uid/gid
  handle_user_group_rules "$table" "whitelist" "uid"
  handle_user_group_rules "$table" "whitelist" "gid"

  # Allow root and dnsmasq
  if [ "$table" = "nat" ]; then
    add_ipt_rule A "${table}" "BOX_LOCAL" "-m owner --uid-owner 0 -j REDIRECT --to-ports ${redir_port}"
    add_ipt_rule A "${table}" "BOX_LOCAL" "-m owner --uid-owner 1052 -j REDIRECT --to-ports ${redir_port}"
  elif [ "$table" = "mangle" ]; then
    for proto in tcp udp; do
      add_ipt_rule A "${table}" "BOX_LOCAL" "-p ${proto} -m owner --uid-owner 0 -j MARK --set-xmark ${MARK_ID}"
      add_ipt_rule A "${table}" "BOX_LOCAL" "-p ${proto} -m owner --uid-owner 1052 -j MARK --set-xmark ${MARK_ID}"
    done
  fi

  log Info "proxy mode: white, ${user_packages_list[*]} transparent proxy"
  log Info "proxy mode: white, GID ${gid_list[*]} transparent proxy"
}

# 处理 UID/GID 规则
handle_user_group_rules() {
  local table="$1"
  local mode="$2"
  local type="$3"

  local list=()
  if [ "$type" = "uid" ]; then
    list=("${uid_list[@]}")
  elif [ "$type" = "gid" ]; then
    list=("${gid_list[@]}")
  fi

  if [ ${#list[@]} -gt 0 ]; then
    for id in "${list[@]}"; do
      if [ "$mode" = "blacklist" ]; then
        add_ipt_rule A "${table}" "BOX_LOCAL" "-m owner --${type}-owner ${id} -j RETURN"
      elif [ "$mode" = "whitelist" ]; then
        if [ "$table" = "nat" ]; then
          add_ipt_rule A "${table}" "BOX_LOCAL" "-m owner --${type}-owner ${id} -j REDIRECT --to-ports ${redir_port}"
        elif [ "$table" = "mangle" ]; then
          add_ipt_rule A "${table}" "BOX_LOCAL" "-p tcp -m owner --${type}-owner ${id} -j MARK --set-xmark ${MARK_ID}"
          add_ipt_rule A "${table}" "BOX_LOCAL" "-p udp -m owner --${type}-owner ${id} -j MARK --set-xmark ${MARK_ID}"
        fi
      fi
    done
    log Info "proxy mode: $mode, ${type}s: ${list[*]} $mode transparent proxy"
  else
    log Info "transparent proxy for all ${type}s"
  fi
}

# 处理 dns 规则
handle_dns_rules() {
  case "$1" in
    redirect)
      setup_dns_redirect_rules "${dns_port}"
      ;;
    tproxy)
      if [ "${mihome_dns_forward}" = "true" ] && [ "${bin_name}" = "mihomo" ] || [ "${bin_name}" = "clash" ] || [ "${bin_name}" = "hysteria" ]; then
        setup_dns_tproxy_return
        setup_dns_redirect_rules "${dns_port}"
      else
        setup_dns_tproxy
      fi
      ;;
  esac
}

# 设置 dns 转发规则
setup_dns_redirect_rules() {
  local dns_port="$1"

  add_ipt_rule N nat DNS_EXTERNAL
  add_ipt_rule N nat DNS_LOCAL

  # handle_core_return_rules nat DNS_EXTERNAL
  handle_core_return_rules nat DNS_LOCAL

  setup_dns_redirect "${dns_port}"

  add_ipt_rule I nat PREROUTING "-j DNS_EXTERNAL"
  add_ipt_rule I nat OUTPUT "-j DNS_LOCAL"
}

# 设置 dns 转发
setup_dns_redirect() {
  local dns_port="$1"
  local ipt_rule="-p udp --dport 53 -j REDIRECT --to-ports ${dns_port}"

  add_ipt_rule A nat DNS_EXTERNAL "${ipt_rule}"
  add_ipt_rule A nat DNS_LOCAL "${ipt_rule}"
}

# 设置 dns 绕过 tproxy
setup_dns_tproxy_return() {
  for proto in tcp udp; do
    add_ipt_rule A mangle BOX_EXTERNAL "-p ${proto} --dport 53 -j RETURN"
    add_ipt_rule A mangle BOX_LOCAL "-p ${proto} --dport 53 -j RETURN"
  done
}

# 设置 dns 通过 tproxy
setup_dns_tproxy() {
  for proto in tcp udp; do
    add_ipt_rule A mangle BOX_EXTERNAL "-p ${proto} --dport 53 -j TPROXY --on-port ${tproxy_port} --tproxy-mark ${MARK_ID}"
    add_ipt_rule A mangle BOX_LOCAL "-p ${proto} --dport 53 -j MARK --set-xmark ${MARK_ID}"
  done
}

# 禁止本地直接访问透明代理端口
reject_local_traffic() {
  local proxy_port="$2"

  case $1 in
    enable)
      ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
      add_ipt_rule A filter OUTPUT "-d 127.0.0.1 -m owner --uid-owner $box_user --gid-owner $box_group --dport $proxy_port -j REJECT"
      ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
      add_ipt_rule A filter OUTPUT "-d ::1 -m owner --uid-owner $box_user --gid-owner $box_group --dport $proxy_port -j REJECT"

      ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
      ;;
    disable)
      iptables -D OUTPUT -d 127.0.0.1 -p tcp -m owner --uid-owner root --gid-owner net_admin -m tcp --dport "$proxy_port" -j REJECT
      ip6tables -D OUTPUT -d ::1 -p tcp -m owner --uid-owner root --gid-owner net_admin -m tcp --dport "$proxy_port" -j REJECT
      iptables -D OUTPUT -d 127.0.0.1 -p tcp -m owner --uid-owner "${box_user}" --gid-owner "${box_group}" -m tcp --dport "$proxy_port" -j REJECT
      ip6tables -D OUTPUT -d ::1 -p tcp -m owner --uid-owner "${box_user}" --gid-owner "${box_group}" -m tcp --dport "$proxy_port" -j REJECT
      ;;
  esac
}

# fakeip 时 ping 假可达
# Fix ICMP (ping), this does not guarantee that the ping result is valid (proxies such as clash do not support forwarding ICMP),
# just that it returns a result, "--to-destination" can be set to a reachable address
fix_fakeip_icmp() {
  case $1 in
    enable)
      ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
      add_ipt_rule A nat PREROUTING "-d ${fake_ip_range_v4} -p icmp -j DNAT --to-destination 127.0.0.1"
      add_ipt_rule A nat OUTPUT "-d ${fake_ip_range_v4} -p icmp -j DNAT --to-destination 127.0.0.1"

      if check_kernel_feature "IP6_NF_TARGET_REDIRECT"; then
        ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
        add_ipt_rule A nat PREROUTING "-d ${fake_ip_range_v6} -p icmp -j DNAT --to-destination ::1"
        add_ipt_rule A nat OUTPUT "-d ${fake_ip_range_v6} -p icmp -j DNAT --to-destination ::1"
      fi

      ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
      ;;
    disable)
      iptables -t nat -D OUTPUT -d "${fake_ip_range_v4}" -p icmp -j DNAT --to-destination 127.0.0.1
      iptables -t nat -D PREROUTING -d "${fake_ip_range_v4}" -p icmp -j DNAT --to-destination 127.0.0.1
      ip6tables -t nat -D OUTPUT -d "${fake_ip_range_v6}" -p icmp -j DNAT --to-destination ::1
      ip6tables -t nat -D PREROUTING -d "${fake_ip_range_v6}" -p icmp -j DNAT --to-destination ::1
      ;;
  esac
}

# 处理 DIVERT 规则
handle_divert_rules() {
  add_ipt_rule N mangle DIVERT

  add_ipt_rule A mangle DIVERT "-j MARK --set-xmark ${MARK_ID}"
  add_ipt_rule A mangle DIVERT "-j ACCEPT"

  add_ipt_rule I mangle PREROUTING "-p tcp -m socket -j DIVERT"
}

# 设置 REDIRECT 模式
setup_redirect() {
  if ! check_kernel_feature "IP_NF_TARGET_REDIRECT"; then
    log Error "REDIRECT IPv4 not supported"
    exit 1
  fi

  if ! validate_vars "redir_port" "dns_port"; then
    exit 1
  fi

  log Info "Initializing REDIRECT proxy method"

  ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
  start_redirect \
    && log Info "Successfully set up REDIRECT rules (IPv4)" \
    || log Error "Failed to setup REDIRECT rules (IPv4)"

  reject_local_traffic enable "${redir_port}"
  fix_fakeip_icmp enable

  if [ "${ipv6}" = "enable" ]; then
    if ! check_kernel_feature "IP6_NF_TARGET_REDIRECT"; then
      log Error "REDIRECT IPv6 not supported"
      return 0
    fi
    intranet6_subnets="($(ip -6 -o addr show | awk '{print $4}' | cut -d/ -f1 | grep -vE '(^::1|^fe80|^fd00)'))"
    ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
    start_redirect \
      && log Info "Successfully set up REDIRECT rules (IPv6)" \
      || log Error "Failed to setup REDIRECT rules (IPv6)"
  fi
}

# 设置 TPROXY 模式
setup_tproxy() {
  if ! check_kernel_feature "NETFILTER_XT_TARGET_TPROXY"; then
    log Warn "TPROXY (IPv4/IPv6) not supported, falling back to REDIRECT"
    setup_redirect
    return 0
  fi

  if ! validate_vars "tproxy_port"; then
    exit 1
  fi

  log Info "Initializing TPROXY proxy method"

  ip_cmd="ip"
  ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
  start_tproxy \
    && log Info "Successfully set up TPROXY rules (IPv4)" \
    || log Error "Failed to setup TPROXY rules (IPv4)"

  reject_local_traffic enable "${tproxy_port}"
  fix_fakeip_icmp enable

  if [ "${ipv6}" = "enable" ]; then
    ip_cmd="ip -6"
    ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
    intranet6_subnets="($(ip -6 -o addr show | awk '{print $4}' | cut -d/ -f1 | grep -vE '(^::1|^fe80|^fd00)'))"
    start_tproxy \
      && log Info "Successfully set up TPROXY rules (IPv6)" \
      || log Error "Failed to setup TPROXY rules (IPv6)"
  fi
}

# 设置防火墙规则
setup_firewall() {
  if ! probe_core_user_group; then
    log Error "Failed to check box_user_group, please make sure ${bin_name} core is started"
    exit 1
  fi

  find_packages_uid
  intranet_subnets="($(ip -4 -o addr show | awk '{print $4}' | grep -v '^127\.'))"

  case "${proxy_method}" in
    TPROXY)
      setup_tproxy
      ;;
    REDIRECT | MIXED)
      setup_redirect
      ;;
    *)
      log Error "Unsupported proxy method: ${proxy_method}"
      return 1
      ;;
  esac

  # handle_ipv6_settings backup

  # if [ "$ipv6" = "enable" ]; then
  #   handle_ipv6_settings disable
  # else
  #   handle_ipv6_settings enable
  # fi
}

# 清理防火墙规则
teardown_firewall() {
  log Info "Tearing down all rules"

  ip_cmd="ip"
  ipt_cmd="iptables -w ${IPTABLES_TIMEOUT}"
  stop_tproxy 2>/dev/null
  stop_redirect 2>/dev/null
  stop_dns_redirect 2>/dev/null

  ip_cmd="ip -6"
  ipt_cmd="ip6tables -w ${IPTABLES_TIMEOUT}"
  stop_redirect 2>/dev/null
  stop_tproxy 2>/dev/null
  stop_dns_redirect 2>/dev/null

  # handle_ipv6_settings restore
}

# handle_ipv6_settings() {}

# 主函数
main() {
  check_dependencies # 执行依赖检查

  case "$1" in
    enable)
      setup_firewall
      ;;
    disable)
      teardown_firewall
      ;;
    renew)
      teardown_firewall
      sleep 1
      setup_firewall
      ;;
    *)
      log Error "Usage: $0 {enable|disable|renew}"
      exit 1
      ;;
  esac
}

# 执行主函数
main "$@"
